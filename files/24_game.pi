/* 

  24 Game (Rosetta Code) in Picat.

  From Rosetta Code
  http://rosettacode.org/wiki/24_game/Solve
  """
  Write a function that given four digits subject to the rules of the 24 game, computes an 
  expression to solve the game if possible.

  Show examples of solutions generated by the function 
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


import util.
% import cp.


main => go.

go =>
   Target = 24,
   Nums = [1+random2() mod 9 : _I in 1..4],
   writeln(nums=Nums),
   All=findall(Expr,catch(solve_num(Nums,Target,Expr),E,ignore(E))),
   foreach(Expr in All) println(Expr.flatten()) end,
   println(len=All.length),
   nl.


go2 =>
  % Different tests from the Rosetta page
  NumsList = [
         [1, 3, 4, 6],
         [6, 8, 2, 8],
         [4, 2, 8, 1],
         [3, 1, 9, 9],
         [5, 7, 5, 1],
         [5, 8, 4, 1],
         [8, 3, 4, 9],
         [3, 7, 4, 4],
         [5, 6, 4, 1],
         [5, 5, 9, 8]
         ],
  Target = 24,
  foreach(Nums in NumsList) 
     writeln(check=Nums),
     All=findall(Expr,catch(solve_num(Nums,Target,Expr),E,ignore(E))),
     foreach(Expr in All) println(Expr.flatten()) end,
     println(len=All.length),
     nl
  end,
  nl.


% What I can see (via some runs of go5/0) the entry with the largest number
% of different solutions is [1,2,3,4].
go3 =>
   Target = 24,
   Nums = [1,2,3,4],
   All=findall(Expr,catch(solve_num(Nums,Target,Expr),E,ignore(E))).remove_dups(),
   foreach(Expr in All) println(Expr.flatten()) end,
   println(len=All.length),
   nl.


% Some of the entries with the largest number of (unique) solutions:
% 326 [1,2,3,4]
% 320 [1,8,1,3]
% 316,[1,7,8,9]
% 238 [4,2,6,2]
% 220 [4,6,8,2]
go4 => 
   MaxLen = 0,
   MaxNums = [],
   Target = 24,
   _ = random2(),
   foreach(_I in 1..100)
      Nums = [1+random() mod 9 : _K in 1..4],
      % pick just the distinct solutions
      All=findall(Expr,catch(solve_num(Nums,Target,Expr),E,ignore(E))).remove_dups(),
      Len = All.length,
      if Len == MaxLen then
         MaxNums := MaxNums ++ [Nums],
         writeln([MaxNums,len=Len])
      elseif Len > MaxLen then
         MaxLen := Len,
         MaxNums := [Nums],
         writeln([MaxNums,len=Len])
      end
   end,
   writeln([MaxLen,MaxNums]),
   nl.



%
% Testing solve_num2/2
%
go5 =>
   Target = 24,
   Nums = [1,2,3,4],
   writeln(nums=Nums),
   solve_num2(Nums,Target),
   nl.

go6 =>
   Target = 24,
   Nums = [1+random2() mod 9 : _I in 1..4],
   writeln(nums=Nums),
   solve_num2(Nums,Target),
   nl.

go7 =>
  NumsList = [
         [6, 8, 2, 8],
         [4, 2, 8, 1],
         [3, 1, 9, 9],
         [5, 7, 5, 1],
         [5, 8, 4, 1],
         [8, 3, 4, 9],
         [3, 7, 4, 4],
         [5, 6, 4, 1],
         [5, 5, 9, 8]
         ],
  Target=24,
  foreach(Nums in NumsList) 
     writeln(check=Nums),
     solve_num2(Nums,Target),
     nl
  end,
  nl.


go8 =>
  Nums = [2,4,6,8],
  Target = 25,
  _All=findall(_, solve_num2(Nums,Target)),
  % foreach(E in All) println(E.to_string()) end,
  nl.

go9 =>
  Nums = [1,5,6,7],
  Target = 21,
  _All=findall(_, solve_num2(Nums,Target)),
  nl.

go10 =>
  Nums = [1,1,5,8],
  Target = 10,
  _All=findall(_, solve_num2(Nums,Target)),
  nl.


%
% A string based approach
%
solve_num(Nums, Target,Expr) => 
   % The different patterns (inspired by - among others - the Perl6 solution)
   Patterns = [
               "A X B Y C Z D",
               "(A X B) Y C Z D",
               "(A X B Y C) Z D",
               "((A X B) Y C) Z D",
               "(A X B) Y (C Z D)",
               "A X (B Y C Z D)",
               "A X (B Y (C Z D))"
               ],
   permutation(Nums,[A,B,C,D]),
   Syms = [+,-,*,/],
   member(X ,Syms),
   member(Y ,Syms),
   member(Z ,Syms),
   member(Pattern,Patterns),
   Expr = replace_all(Pattern, 
                      "ABCDXYZ", % ['A','B','C','D','X','Y','Z'],
                      [A,B,C,D,X,Y,Z]),
   % =:= for numerical equality
   catch(Target =:= Expr.eval(),E,ignore(E)).

%
% Replace all occurrences in the lists From -> To 
% in the String (or List) S.
%
replace_all(S,From,To) = Res =>
   R = S,
   foreach({F,T} in zip(From,To))
      R := replace(F,T.to_string(), R)
   end,
   Res = R.

% replace occurrences of Old (a variable or an atomic value) with New
% From http://picat-lang.org/download/exs.pi
replace(Old,New,[H|T]) = [NH|NT] => 
    NH = replace(Old,New,H), 
    NT = replace(Old,New,T).
replace(Old,New,T)=NT,struct(T) => 
    NT = new_struct(T.name,T.length),
    foreach(I in 1 .. T.length) 
        NT[I] = replace(Old,New,T[I]) 
    end.
replace(Old,New,Old) = New.
replace(_Old,_New,T) = T.


% ignore zero_divisor errors
ignore(_E) => fail.

% E=["4","+","3","-","2"].flatten().eval()
% E=["4","-","(","3","-","2",")"].eval()
eval(Expr) = parse_term(Expr.flatten()).apply().



% 
% Alternative approach
% 
solve_num2(Nums, Target) =>
    Syms = [+,-,*,/],
    Perms = permutations([I.to_string() : I in Nums]),
    Seen = new_map(), % weed out duplicates
    foreach(X in Syms,Y in Syms, Z in Syms)
        foreach(P in Perms) 
           [A,B,C,D] = P,
           if catch(check(A,X,B,Y,C,Z,D,Target,Expr),E,ignore(E)), 
              not Seen.has_key(Expr) then
                println(Expr.flatten()=Expr.eval().round()),
                Seen.put(Expr,1)
           end
        end
    end.

to_string2(Expr) = [E.to_string() : E in Expr].flatten().

check(A,X,B,Y,C,Z,D,Target,Expr) ?=> 
   Expr = ["(",A,Y,B,")",X,"(",C,Z,D,")"].to_string2(),
   Target =:= Expr.eval().

check(A,X,B,Y,C,Z,D,Target,Expr) ?=> 
   Expr = [A,X,"(",B,Y,"(",C,Z,D,")",")"].to_string2(),
   Target =:= Expr.eval().

check(A,X,B,Y,C,Z,D,Target,Expr) ?=> 
   Expr = ["(","(",C,Z,D,")",Y,B,")",X,A].to_string2(),
   Target =:= Expr.eval().

check(A,X,B,Y,C,Z,D,Target,Expr) ?=> 
   Expr = ["(",B,Y,"(",C,Z,D,")",")",X,A].to_string2(),
   Target =:= Expr.eval().

check(A,X,B,Y,C,Z,D,Target,Expr) => 
   Expr = [A,X,"(","(",B,Y,C,")", Z,D,")"].to_string2(),
   Target =:= Expr.eval().

